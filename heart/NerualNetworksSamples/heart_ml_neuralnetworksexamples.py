# -*- coding: utf-8 -*-
"""Heart_ML_NeuralNetworksExamples.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YfOYtVahq6FqBEVL4HhUsPdYwDZLh7A6
"""

##import all:
import numpy
import pandas
from keras.models import Sequential
from keras.layers import Dense
from keras.wrappers.scikit_learn import KerasRegressor
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import KFold
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline

# load dataset
url_input = "https://raw.githubusercontent.com/AigerimJ/heart_disease/master/heart/train/train_values.csv?token=ATmRgOC2Z57N9x2_xJ9Uj_9rWjrGvjPrks5cleXwwA%3D%3D"
# df = pandas.read_csv(url, delim_whitespace=True, header=None)
url_output = "https://raw.githubusercontent.com/AigerimJ/heart_disease/master/heart/train/train_labels.csv?token=ATmRgKqn1MgBzsqPavDHl89xvsH9-dPUks5clfqiwA%3D%3D"


df_input = pandas.read_csv(url_input)
df_output = pandas.read_csv(url_output)

dataset_input = df_input.values
dataset_output = df_output.values

# split into input (X) and output (Y) variables
# X = dataset_input[:,1:14]
# Y = dataset_output[:,1]

for i in range(len(X)):
  if (X[i][1] == 'normal'):
    X[i][1] = 0
    
  if (X[i][1] == 'fixed_defect'):
    X[i][1] = 1
    
  if (X[i][1] == 'reversible_defect'):
    X[i][1] = 2

print(" X = ",X)
print("\nY = ",Y)

"""# Training a Baseline model"""

# define base model
def baseline_model():
    # create model
    model = Sequential()
    model.add(Dense(3, input_dim=13, kernel_initializer='normal', activation='relu'))
    model.add(Dense(1, kernel_initializer='normal'))
    # Compile model
    model.compile(loss='mean_squared_error', optimizer='adam')
    return model

# fix random seed for reproducibility
seed = 7
numpy.random.seed(seed)
# evaluate model with standardized dataset
estimator = KerasRegressor(build_fn=baseline_model, nb_epoch=100, batch_size=5, verbose=0)

kfold = KFold(n_splits=10, random_state=seed)
results = cross_val_score(estimator, X, Y, cv=kfold)

print(results)
print("Results: %.2f (%.2f) MSE" % (results.mean(), results.std()))

"""# Evaluating model with standardized dataset"""

# evaluate model with standardized dataset
numpy.random.seed(seed)
estimators = []
estimators.append(('standardize', StandardScaler()))
estimators.append(('mlp', KerasRegressor(build_fn=baseline_model, epochs=50, batch_size=5, verbose=0)))
pipeline = Pipeline(estimators)
kfold = KFold(n_splits=10, random_state=seed)
results = cross_val_score(pipeline, X, Y, cv=kfold)
print("Standardized: %.2f (%.2f) MSE" % (results.mean(), results.std()))

"""# Using the trained models to predict result on new data"""

pipeline.fit(X,Y) # Fit model

## data to test:

url_test = "https://raw.githubusercontent.com/AigerimJ/heart_disease/master/heart/train/train_values_labels.csv?token=ATmRgJBfnKiWhBF12_5Yu0mR4AQeg5NFks5clgYrwA%3D%3D"
df = pandas.read_csv(url_test)
dataset = df.values

# split into input (X) and output (Y) variables
X_new = dataset[:,1:14]
Y_new = dataset[:,14]

for i in range(len(X_new)):
  if (X_new[i][1] == 'normal'):
    X_new[i][1] = 0
    
  if (X_new[i][1] == 'fixed_defect'):
    X_new[i][1] = 1
    
  if (X_new[i][1] == 'reversible_defect'):
    X_new[i][1] = 2

# print(" X_new = ",X_new)

# print(X_new[0].shape)
# print(X_new[2].shape)

for i in range(len(X_new)):
  pipeline.predict([X_new[i]])

Y_pred = numpy.empty((len(X_new), 1))

for i in range(len(X_new)):
  Y_pred[i] += pipeline.predict([X_new[i]])
  
#   if (Y_pred[i] < 0.5):
#     Y_pred[i] = 0
#   else: 
#     Y_pred[i] = 1

  print(i,") Labeled case: %2f" %Y_new[i], " Prediction: %2f" %Y_pred[i])


# Y_pred = pipeline.predict([X_new[0]])
# print("Labeled case: %2f" %Y_new[0])
# print("Prediction: %2f" %Y_pred)

"""# A larger network"""

def larger_model():
    # create model
    model = Sequential()
    model.add(Dense(13, input_dim=13, kernel_initializer='normal', activation='relu')) # input layer; size 13
    model.add(Dense(6, kernel_initializer='normal', activation='relu')) # hidden layer; size 6
    model.add(Dense(1, kernel_initializer='normal')) # output layer; size 1 with no activation since it's a regression problem
    # Compile model
    model.compile(loss='mean_squared_error', optimizer='adam')
    return model

# evaluation on the larger net
numpy.random.seed(seed)
estimators = []
estimators.append(('standardize', StandardScaler()))
estimators.append(('mlp', KerasRegressor(build_fn=larger_model, epochs=50, batch_size=5, verbose=0)))
pipeline = Pipeline(estimators)
kfold = KFold(n_splits=10, random_state=seed)
results = cross_val_score(pipeline, X, Y, cv=kfold)
print("Larger: %.2f (%.2f) MSE" % (results.mean(), results.std()))

pipeline.fit(X,Y) # Fit model

for i in range(len(X_new)):
  pipeline.predict([X_new[i]])
  
Y_pred = numpy.empty((len(X_new), 1))

for i in range(len(X_new)):
  Y_pred[i] += pipeline.predict([X_new[i]])
  
#   if (Y_pred[i] < 0.5):
#     Y_pred[i] = 0
#   else: 
#     Y_pred[i] = 1

  print(i,") Labeled case: %2f" %Y_new[i], " Prediction: %2f" %Y_pred[i])

"""##Wider network"""

# define wider model
def wider_model():
    # create model
    model = Sequential()
    model.add(Dense(13, input_dim=13, kernel_initializer='normal', activation='relu'))
    model.add(Dense(1, kernel_initializer='normal'))
    # Compile model
    model.compile(loss='mean_squared_error', optimizer='adam')
    return model
  
numpy.random.seed(seed)
estimators = []
estimators.append(('standardize', StandardScaler()))
estimators.append(('mlp', KerasRegressor(build_fn=wider_model, epochs=100, batch_size=5, verbose=0)))
pipeline = Pipeline(estimators)
kfold = KFold(n_splits=10, random_state=seed)
results = cross_val_score(pipeline, X, Y, cv=kfold)
print("Wider: %.2f (%.2f) MSE" % (results.mean(), results.std()))

pipeline.fit(X,Y) # Fit model

for i in range(len(X_new)):
  pipeline.predict([X_new[i]])
  
Y_pred = numpy.empty((len(X_new), 1))

for i in range(len(X_new)):
  Y_pred[i] += pipeline.predict([X_new[i]])
  
#   if (Y_pred[i] < 0.5):
#     Y_pred[i] = 0
#   else: 
#     Y_pred[i] = 1

  print(i,") Labeled case: %2f" %Y_new[i], " Prediction: %2f" %Y_pred[i])

